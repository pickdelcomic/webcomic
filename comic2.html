// === PART 1: Battle Setup ===
const battleCanvas = document.createElement("canvas");
battleCanvas.width = 600;
battleCanvas.height = 300;
battleCanvas.style.border = "2px solid white";
battleCanvas.style.margin = "20px";
battleCanvas.style.display = "none";
document.body.insertBefore(battleCanvas, document.querySelector(".navigation"));

const ctx = battleCanvas.getContext("2d");

let state = {
  characters: [
    { name: "Pomgrante", hp: 100, maxHp: 100, action: null },
    { name: "Potota", hp: 160, maxHp: 160, action: null },
    { name: "Burger Shirt", hp: 120, maxHp: 120, action: null }
  ],
  enemy: { name: "Layla", hp: 250, maxHp: 250 },
  turnIndex: 0,
  substate: "select", // select, options, confirm, attack, enemyTurn
  selectedOption: 0,
  attackConfirmed: false
};

const actions = {
  Pomgrante: ["Gun", "Talk"],
  Potota: ["Encourage", "Talk"],
  "Burger Shirt": ["Mercy"]
};

const talkOptions = {
  Pomgrante: ["What’s your deal?", "You’re kinda cool", "Sorry for shooting you"],
  Potota: ["Want a hug?", "We come in peace", "You look weird"],
  "Burger Shirt": ["Please go away", "Wanna collab?", "I believe in you"]
};

function drawUI() {
  ctx.clearRect(0, 0, battleCanvas.width, battleCanvas.height);

  // Draw characters
  ctx.fillStyle = "white";
  ctx.font = "16px monospace";
  ctx.fillText("== YOUR TEAM ==", 10, 20);

  state.characters.forEach((ch, i) => {
    let y = 40 + i * 30;
    ctx.fillStyle = state.turnIndex === i ? "yellow" : "white";
    ctx.fillText(`${ch.name}: ${ch.hp}/${ch.maxHp}`, 10, y);
  });

  ctx.fillStyle = "red";
  ctx.fillText(`ENEMY: ${state.enemy.name} ${state.enemy.hp}/${state.enemy.maxHp}`, 10, 150);

  // Options UI
  ctx.fillStyle = "white";
  ctx.fillText("Select Action:", 10, 180);

  let currentChar = state.characters[state.turnIndex];
  let opts = actions[currentChar.name];
  if (state.substate === "options") {
    opts.forEach((opt, i) => {
      ctx.fillStyle = i === state.selectedOption ? "cyan" : "white";
      ctx.fillText(opt, 30 + i * 100, 210);
    });
  }

  if (state.substate === "talk") {
    let talks = talkOptions[currentChar.name];
    talks.forEach((line, i) => {
      ctx.fillStyle = i === state.selectedOption ? "cyan" : "white";
      ctx.fillText(line, 30, 210 + i * 20);
    });
  }

  if (state.substate === "confirm") {
    ctx.fillStyle = "cyan";
    ctx.fillText("Press Z to launch attack!", 10, 270);
  }

  if (state.substate === "enemyTurn") {
    ctx.fillStyle = "red";
    ctx.fillText("ENEMY IS ATTACKING!", 10, 270);
  }
}
// === PART 2: Controls & Input ===
document.addEventListener("keydown", (e) => {
  const currentChar = state.characters[state.turnIndex];

  if (state.substate === "options") {
    if (e.key === "ArrowRight") {
      state.selectedOption = (state.selectedOption + 1) % actions[currentChar.name].length;
    } else if (e.key === "ArrowLeft") {
      state.selectedOption = (state.selectedOption - 1 + actions[currentChar.name].length) % actions[currentChar.name].length;
    } else if (e.key === "z") {
      const selectedAction = actions[currentChar.name][state.selectedOption];
      if (selectedAction === "Talk") {
        state.substate = "talk";
        state.selectedOption = 0;
      } else {
        currentChar.action = selectedAction;
        advanceTurn();
      }
    }
  } else if (state.substate === "talk") {
    const talks = talkOptions[currentChar.name];
    if (e.key === "ArrowDown") {
      state.selectedOption = (state.selectedOption + 1) % talks.length;
    } else if (e.key === "ArrowUp") {
      state.selectedOption = (state.selectedOption - 1 + talks.length) % talks.length;
    } else if (e.key === "z") {
      currentChar.action = `Talk: ${talks[state.selectedOption]}`;
      advanceTurn();
    } else if (e.key === "x") {
      state.substate = "options";
      state.selectedOption = 0;
    }
  } else if (state.substate === "confirm") {
    if (e.key === "z") {
      state.substate = "attack";
      launchAttack();
    }
  }
});

function advanceTurn() {
  state.turnIndex++;
  state.selectedOption = 0;

  if (state.turnIndex >= state.characters.length) {
    state.substate = "confirm";
    state.turnIndex = 0;
  } else {
    state.substate = "options";
  }
}
// === PART 3: Minigame, Attack, Render ===

function launchAttack() {
  state.enemy.hp -= 0; // damage comes from minigame
  startMinigame();
}

function startMinigame() {
  const targets = [];
  for (let i = 0; i < 5; i++) {
    targets.push({
      x: Math.random() * 240 + 50,
      y: Math.random() * 80 + 40,
      alive: true
    });
  }
  state.minigame = { cursorX: 160, targets, timer: 100 };

  const gameLoop = setInterval(() => {
    const mg = state.minigame;
    if (!mg) {
      clearInterval(gameLoop);
      return;
    }
    mg.timer--;

    render();

    if (mg.timer <= 0) {
      const hits = mg.targets.filter(t => !t.alive).length;
      const damage = hits * 20;
      state.enemy.hp -= damage;
      state.minigame = null;

      setTimeout(() => {
        enemyTurn();
      }, 1000);

      clearInterval(gameLoop);
    }
  }, 100);

  document.addEventListener("keydown", minigameInput);
}

function minigameInput(e) {
  const mg = state.minigame;
  if (!mg) return;
  if (e.key === "ArrowLeft") mg.cursorX -= 10;
  if (e.key === "ArrowRight") mg.cursorX += 10;
  if (e.key === "z") {
    mg.targets.forEach(t => {
      if (t.alive && Math.abs(t.x - mg.cursorX) < 20) t.alive = false;
    });
  }
}

function enemyTurn() {
  const dmg = Math.floor(Math.random() * 20) + 30;
  const target = state.characters[Math.floor(Math.random() * state.characters.length)];
  target.hp = Math.max(0, target.hp - dmg);

  setTimeout(() => {
    state.turnIndex = 0;
    state.characters.forEach(c => c.action = null);
    state.substate = "options";
    render();
  }, 1000);
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // UI Frame
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Enemy
  ctx.fillStyle = "red";
  ctx.font = "bold 20px sans-serif";
  ctx.fillText(`LAYLA HP: ${state.enemy.hp}`, 150, 30);

  // Characters
  state.characters.forEach((char, i) => {
    ctx.fillStyle = i === state.turnIndex && state.substate === "options" ? "yellow" : "white";
    ctx.fillText(`${char.name}: ${char.hp} HP`, 10, 60 + i * 20);
  });

  // Substates
  const currentChar = state.characters[state.turnIndex];
  if (state.substate === "options") {
    const opts = actions[currentChar.name];
    opts.forEach((opt, i) => {
      ctx.fillStyle = i === state.selectedOption ? "lime" : "white";
      ctx.fillText(opt, 150 + i * 80, 100);
    });
  } else if (state.substate === "talk") {
    const opts = talkOptions[currentChar.name];
    opts.forEach((opt, i) => {
      ctx.fillStyle = i === state.selectedOption ? "cyan" : "white";
      ctx.fillText(opt, 10, 150 + i * 20);
    });
    ctx.fillStyle = "gray";
    ctx.fillText("[X] Cancel", 10, 240);
  } else if (state.substate === "confirm") {
    ctx.fillStyle = "white";
    ctx.fillText("Press Z to LAUNCH ATTACK!", 100, 200);
  }

  // Minigame
  if (state.minigame) {
    ctx.fillStyle = "orange";
    state.minigame.targets.forEach(t => {
      if (t.alive) ctx.fillRect(t.x, t.y, 10, 10);
    });

    ctx.strokeStyle = "white";
    ctx.beginPath();
    ctx.moveTo(state.minigame.cursorX, 120);
    ctx.lineTo(state.minigame.cursorX, 130);
    ctx.stroke();
  }
}

setInterval(render, 100);
